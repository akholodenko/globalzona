package com.myspace.sdk.oAuth{		import com.myspace.sdk.Utils.ObjectUtils;	import com.myspace.sdk.Utils.URLEncoding;	import com.myspace.sdk.oAuth.Hurlant.util.*;		import flash.net.URLRequestHeader;	import flash.net.URLVariables;	import flash.utils.ByteArray;	/**	 * The OAuthRequest class is the workhorse class.	 * This is the class you will use to generate and sign your OAuth requests.	*/	public class OAuthRequest	{		private var _httpMethod:String;		private var _requestURL:String;		private var _requestParams:Object;		private var _excludedParams:Object = null;		private var _consumer:OAuthConsumer;		private var _token:OAuthToken;				private var _version:String = "AS3_1.0";		/**		 * Constructor method.		 * 		 * (ADK)		 * @excludedParams is an object of key/value pairs that will be excluded from URL query string (not from signature)		 * This is needed for PUT (POST) requests 		*/		public function OAuthRequest(httpMethod:String,requestURL:String,requestParams:Object=null,consumer:OAuthConsumer=null,token:OAuthToken=null,excludedParams:Object=null)		{			_httpMethod = httpMethod;			_requestURL = requestURL;			if (!requestParams) {				requestParams = {};			}			_requestParams = requestParams;						if (!excludedParams) {				excludedParams = {};			}						this._excludedParams = excludedParams;			_consumer = consumer;			_token = token;		}		/**		 * The HTTP request method used to send the request. Value MUST be uppercase, for example:		 * HEAD, GET , POST, etc.		*/		public function get httpMethod():String {			return _httpMethod;		}		/**		 * @private		*/		public function set httpMethod(val:String):void {			if (val != _httpMethod)				_httpMethod = val;		}		/**		 * The requestURL MUST include the scheme, authority, and path, and MUST exclude the query string.		*/		public function get requestURL():String {			return _requestURL;		}		/**		 * @private		*/		public function set requestURL(val:String):void {			if (val != _requestURL)				_requestURL = val;		}		/**		 * The requestParams object must be a simple object with name value pairs, with the value being		 * able to be converted to a string. Example: { title: "My Book title", pageCount: 10, inLibrary: true }		*/		public function get requestParams():Object {			return _requestParams;		}		/**		 * @private		*/		public function set requestParams(val:Object):void {			if (val != _requestParams)				_requestParams = val;		}		/**		 *		*/		public function get consumer():OAuthConsumer {			return _consumer;		}		/**		 * @private		*/		public function set consumer(val:OAuthConsumer):void {			_consumer = val;		}		/**		 *		*/		public function get token():OAuthToken {			return _token;		}		/**		 * @private		*/		public function set token(val:OAuthToken):void {			_token = val;		}		public static const RESULT_TYPE_URL_STRING:String = "url";		public static const RESULT_TYPE_URL_VARIABLES:String = "urlVariables";		public static const RESULT_TYPE_POST:String = "post";		public static const RESULT_TYPE_HEADER:String = "header";		/* KDF: change to remove the Flex dependency of this class. */		public function generateKey(bytes:uint):String		{			var rnd:ByteArray = new ByteArray();			for (var i:uint = 0; i < bytes; ++i) rnd.writeByte(Math.random() * 255.5);			var enc:String = Base64.encodeByteArray(rnd);			enc = enc.replace(/\W/g, "");			return enc;		}		/* KDF: end change. */				/**		 * Builds out the request as you need to use it.		*/		public function buildRequest(signatureMethod:IOAuthSignatureMethod,resultType:String=RESULT_TYPE_URL_STRING,headerRealm:String=""):* {			var curDate:Date = new Date();			/* KDF: change to remove the Flex dependency of this class. */			//var uuid:String = UIDUtil.getUID(curDate);			var uuid:String = generateKey(8);			/* KDF: end change. */			// first, let's add the oauth required params			_requestParams["oauth_nonce"] = uuid;			_requestParams["oauth_timestamp"] = String(curDate.time).substring(0, 10);			_requestParams["oauth_consumer_key"] = _consumer.key;			_requestParams["oauth_signature_method"] = signatureMethod.name;			_requestParams["oauth_version"] = "1.0";			_requestParams["msid_sdk"] = this._version;			// if there already is a token, add that too			if (_token) {				_requestParams["oauth_token"] = _token.key;			} else {				// if there is no token, remove any old ones				if (_requestParams.hasOwnProperty("oauth_token"))					var checkDelete:Boolean = delete(_requestParams.oauth_token);			}			// generate the signature			var signature:String = signatureMethod.signRequest(this);			_requestParams["oauth_signature"] = signature;			switch (resultType) {				case RESULT_TYPE_URL_STRING:					var ret1:String = _requestURL + "?" + getParameters();					return ret1;				break;				case RESULT_TYPE_URL_VARIABLES:					// this is possibly going to give you corrupt results, because the					// flash player auto-encodes URLVariables, but not according to spec					var ret2:URLVariables = new URLVariables();					for (var param:Object in _requestParams) {						ret2[param] = _requestParams[param];					}					return ret2;				break;				case RESULT_TYPE_POST:					var ret4:String = getParameters();					return ret4;				break;				case RESULT_TYPE_HEADER:					var data:String = "";					data += "OAuth "					if (headerRealm.length > 0)						data += "realm=\"" + headerRealm + "\"";					for (param in _requestParams) {						// if this is an oauth param, include it						if (param.toString().indexOf("oauth") == 0) {							data += "," + param + "=\"" + URLEncoding.encode(_requestParams[param]) + "\"";						}					}					var ret3:URLRequestHeader = new URLRequestHeader("Authorization",data);					return ret3;				break;			}		}		/**		 * Returns a string that consists of all the parameters that need to be signed		*/		private function getSignableParameters():String {			var aParams:Array = new Array();			// loop over params, find the ones we need			for (var param:String in _requestParams) 			{				if (param != "oauth_signature")				{					/* KDF: hack to allow for multiple values to be passed for the same parameter name. */					if (_requestParams[param] is Array)						for (var element:String in _requestParams[param]) aParams.push(param + "=" + _requestParams[param][element].toString());					else					/* KDF: end hack */					{						/* ADK: hack to urlEncode specific values an extra time for system to accept base string */						if(param == "oauth_consumer_key" || param == "show" || param == "caption" || param == "activityTypes" || param == "extensions" || param == "oauth_token" || param == "status" || param == "oauth_callback")						{							var paramValue:String = URLEncoding.encode(_requestParams[param].toString());							/* 	local URLEncoder encodes blank space as +, while the server encodes as %20								for signature to match, must replace + with %20 */														if(paramValue.indexOf("+") != -1)								paramValue = paramValue.split("+").join("%20");														aParams.push(param + "=" + paramValue);						}												/* ADK: end hack */						else							aParams.push(param + "=" + _requestParams[param].toString());					}				}			}			// put them in the right order			aParams.sort();			// return them like a querystring			return aParams.join("&");		}		/**		 * Returns a string that consists of all the parameters that need to be signed		*/		private function getParameters():String {			var aParams:Array = new Array();						// loop over params, find the ones we need			for (var param:String in _requestParams) 			{				if(!ObjectUtils.isParamInObject(param,this._excludedParams)) //ADK: hack to exclude list of params from query string; needed for PUT (POST)				{					/* KDF: hack to allow for multiple values to be passed for the same parameter name. */					if (_requestParams[param] is Array)						for (var element:String in _requestParams[param]) aParams.push(param + "=" + URLEncoding.encode(_requestParams[param][element].toString()));					else					/* KDF: end hack */						aParams.push(param + "=" + URLEncoding.encode(_requestParams[param].toString()));				}			}			// put them in the right order			aParams.sort();			// return them like a querystring			return aParams.join("&");		}		/**		 * Returns the signable string		*/		public function getSignableString():String {			// create the string to be signed			var ret:String = URLEncoding.encode(_httpMethod.toUpperCase());			ret += "&";			ret += URLEncoding.encode(_requestURL);			ret += "&";			ret += URLEncoding.encode(getSignableParameters());			return ret;		}	}}
